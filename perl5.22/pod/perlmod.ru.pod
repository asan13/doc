=encoding utf8

=head1 НАЗВАНИЕ

perlmod - модули Perl (пакеты и таблицы симолов)

=head1 ОПИСАНИЕ

=head2 Is this the document you were after?

Существуют другие документы, которые могут содержать нужную вам иинформацию:
There are other documents which might contain the information that you're
looking for:

=over 2

=item В этом документе 

Пакеты, пространства имен и некоторая информация о классах в Perl.

=item L<perlnewmod>

Руководство по созданию современных модулей.

=item L<perlmodstyle>

Лучшие практики по созданию современных модулей.

=back

=head2 Пакеты
X<package> X<namespace> X<variable, global> X<global variable> X<global>

Perl предоставляет механизм изменения пространства имен для защиты пакетов от
засорения друг друга всеми своими переменными. Фактически, в Perl нет такой 
вещи, как глобальные переменные. Инструкция package объявляет единицу
компиляции, находящуюся в данном пространстве имен. Область действия
объявления пакета начинается от самого объявления и простирается дол конца
окружающего блока, C<eval> или файла, взависимости от того, что будет первым
(такую же область имеют операторы my() и local()). Неквалифицированные
динамические идентификаторы будут находится в этом пространстве имен, за 
исключением тех немногих идентификаторов, которые, будучи
неквалифицированными, по умолчанию находятся в пакете main, как будет описано
ниже. Инструкция package затрагивает только на динамические
переменные--включая те, к которым применили local()--но I<не> на лексические 
переменные, создаваемые при помощи my(). Обычно package будет первым
объявлением в файле, который вы подключаете используя операторы C<do>,
C<require> или C<use>. Вы можете перключится в пакет в различных местах; это
переключение влият только на то, какая таблица сиволов будет использоваться
компилятором до конца этого блока. На переменные и файловые указатели в пакете
можно ссылаться из других пакетов, предваряя имя переменной именем пакета и
двойным двоеточием: C<Package::Variable>. Если имя пакета отсутствует,
подразумевается пакет main. То есть C<$::sail> эквивалентно C<$main::seil>.

В старину разделителем пакета служила одинарная кавычка, но сейчас
предпочтительно использовать двойное двоеточие, оно более человекочитаемо, и
также лучше читается в макросах B<emacs>. Также два двоеточия позволяют С++ 
программистам чувствовать, что они понимают, что происходит--в отличии от 
разделителя одинарная кавычка, позволявшей испытывать похожее чувство Ada
программистам. Поскольку старомодный синтаксис все еще поддерживается для
обеспечения обратной совместимости, если вы попытаетесь использовать подобную
строку C<"This is $owner's house">, вы обратитесь к C<$owner::s>; то есть, к
переменной $s в пакете C<owner>, что вероятно не то, что вы хотели.
Используйте фигурные скобки для устранения неоднозначности, как здесь C<"This
is ${owner}'s house">.
X<::> X<'>

Пакеты сами могут содержать разделители пакетов, например
C<$OUTER::INNER::var>. Однако это ничего не подразумевает о порядке поиска 
имен. Нет относительных пакетов: все символы либо локальны в текущем пакете, 
либо должны быть полностью квалифицированы от внешнего пакета.  Например, в 
пакете C<OUTER> ничто не позволит C<$INNER::var> относиться к 
C<$OUTER::INNER::var>. C<INNER> относится к полностью отдельному глоьбальному 
пакету.

В таблице символов пакета хранятся только идентификаторы, начинающиеся с 
буквы или знака подчеркивания. Все другие символы, включая пунктуационные
переменные подобно $_, хранятся в пакете C<main>. В добавок, идентификаторы 
STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC и SIG, если они не
квалифицированы, принудительно помещаются в C<main>, даже когда они
используются для других целей, нежели предназначены изначально.  Если вы 
назовете свои пакеты C<m>, C<s> или C<y>, вы не сможете использовать
квалифицированую форму идентификатора, поскольку она будет интерпретирована
как поиск по шаблону, замена или транслитерация, соответственно.
X<variable, punctuation> 

Переменные, начинающиеся с нижнего подчеркивания, ранее использовались для
принудительного помещения в пакет main, но мы решили, что они более полезны
разработчикам пакетов для индикации имен приватных переменных и методов. 
Однако, имена переменных и функций, состоящие из едиственного C<_>, такие как 
C<$_> или C<sub _>, по прежнему принудительно находятся в пакете C<main>.
Смотрите также L<perlvar/"The Syntax of Variable Names">.

Обрабатываемые C<eval>-м строки компилируются в том же пакете, в котором
компилируется eval(). (Однако, при присваивании C<$SIG{}> полагается, что
обработчик сигнала определен в пакете C<main>. Квалифицируйте имя обработчика
сигнала, если хотите использовать обработчик сигнала из пакета.) Для примера
взгляните на F<perldb.pl> из библиотеки Perl. В начале работы он переключается
на пакет C<DB>, что бы отладчик не мешал работать с переменными в
отлаживаемой программе.







=cut

